-- VHDL Entity Board.poetic_circuit.symbol
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 16:00:43 12.08.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY poetic_circuit IS
    GENERIC( 
        bitNb : positive := 16
    );
    PORT( 
        ADC0_SDO : IN     std_uLogic;
        Hall_A   : IN     std_ulogic;
        Hall_B   : IN     std_ulogic;
        Hall_C   : IN     std_ulogic;
        USB_TX   : IN     std_ulogic;
        clock    : IN     std_ulogic;
        reset_N  : IN     std_ulogic;
        ADC0_CS  : OUT    std_uLogic;
        ADC_SCLK : OUT    std_uLogic;
        DAC_SCLK : OUT    std_ulogic;
        DAC_SDO  : OUT    std_ulogic;
        DAC_SYNC : OUT    std_ulogic;
        LED0_0   : OUT    std_uLogic;
        LED0_1   : OUT    std_uLogic;
        Sa_bot   : OUT    std_ulogic;
        Sa_top   : OUT    std_ulogic;
        Sb_bot   : OUT    std_ulogic;
        Sb_top   : OUT    std_ulogic;
        Sc_bot   : OUT    std_ulogic;
        Sc_top   : OUT    std_ulogic;
        USB_RX   : OUT    std_ulogic
    );

-- Declarations

END poetic_circuit ;





-- VHDL Entity Poetic.SimplePoeticBLDC.symbol
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 14:46:45 28.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY SimplePoeticBLDC IS
    GENERIC( 
        pidBitNb   : positive := 12;
        dacBitNb   : positive := 8;
        dacopBitNb : positive := 2;
        dacchBitNb : positive := 2;
        dataBitNb  : positive := 8
    );
    PORT( 
        ADC0_SDO   : IN     std_ulogic;
        D          : IN     std_ulogic;
        Hall_A     : IN     std_ulogic;
        Hall_B     : IN     std_ulogic;
        Hall_C     : IN     std_ulogic;
        I          : IN     std_ulogic;
        P          : IN     std_ulogic;
        USB_TX     : IN     std_ulogic;
        clock      : IN     std_ulogic;
        enable     : IN     std_ulogic;
        reset      : IN     std_ulogic;
        ADC0_CS    : OUT    std_ulogic;
        ADC_SCLK   : OUT    std_ulogic;
        DAC0_SCLK  : OUT    std_ulogic;
        DAC0_SDO   : OUT    std_ulogic;
        DAC0_SYNC  : OUT    std_ulogic;
        Sa_bot     : OUT    std_ulogic;
        Sa_top     : OUT    std_ulogic;
        Sb_bot     : OUT    std_ulogic;
        Sb_top     : OUT    std_ulogic;
        Sc_bot     : OUT    std_ulogic;
        Sc_top     : OUT    std_ulogic;
        USB_RX     : OUT    std_ulogic;
        ledState_0 : OUT    std_ulogic;
        ledState_1 : OUT    std_ulogic
    );

-- Declarations

END SimplePoeticBLDC ;





-- VHDL Entity RS232.serialPortFIFO.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:49 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortFIFO IS
    GENERIC( 
        baudRateDivide : positive := 2083;
        dataBitNb      : positive := 8;
        txFifoDepth    : positive := 8;
        rxFifoDepth    : positive := 8
    );
    PORT( 
        RxD     : IN     std_ulogic;
        TxD     : OUT    std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        rxEmpty : OUT    std_ulogic;
        rxRd    : IN     std_ulogic;
        rxData  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txData  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txFull  : OUT    std_ulogic;
        txWr    : IN     std_ulogic
    );

-- Declarations

END serialPortFIFO ;





-- VHDL Entity RS232.serialPortReceiver.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:48 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortReceiver IS
    GENERIC( 
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT( 
        RxD       : IN     std_ulogic;
        clock     : IN     std_ulogic;
        reset     : IN     std_ulogic;
        dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataValid : OUT    std_ulogic
    );

-- Declarations

END serialPortReceiver ;





--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Common Lib
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
--     added documentation
-- -----------------------------------------------------------------------------
library IEEE;
  use IEEE.std_logic_1164.all;
  use IEEE.numeric_std.all;

PACKAGE CommonLib IS

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to represent the given val
  -- Examples:
  --   requiredBitNb(1) = 1   (1)
  --   requiredBitNb(2) = 2   (10)
  --   requiredBitNb(3) = 2   (11)
  function requiredBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Returns the number of bits needed to count val times (0 to val-1)
  -- Examples:
  --   counterBitNb(1) = 1    (0)
  --   counterBitNb(2) = 1    (0->1)
  --   counterBitNb(3) = 2    (0->1->10)
  function counterBitNb(val : integer) return integer;

  ------------------------------------------------------------------------------
  -- Functions to return one or the other input based on a boolean.
  -- Can be used to build conditional constants.
  -- Example:
  --   constant bonjour_c : string := sel(ptpRole = master, "fpga20", "fpga02");
  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer;
  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string;
  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector;
  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned;
  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed;

END CommonLib;




--------------------------------------------------------------------------------
-- Copyright 2012 HES-SO Valais Wallis (www.hevs.ch)
--------------------------------------------------------------------------------
-- This program is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation; either version 3 of the License, or
-- (at your option) any later version.
--
-- This program IS distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU General Public License for more details.
-- You should have received a copy of the GNU General Public License along with
-- this program. If not, see <http://www.gnu.org/licenses/>
-- -----------------------------------------------------------------------------
-- Often used functions
--
-- -----------------------------------------------------------------------------
--  Authors:
--    cof: [François Corthay](francois.corthay@hevs.ch)
--    guo: [Oliver A. Gubler](oliver.gubler@hevs.ch)
-- -----------------------------------------------------------------------------
-- Changelog:
--   2016-06 : guo
--     added function sel
--   2015-06 : guo
--     added counterBitNb
-- -----------------------------------------------------------------------------
PACKAGE BODY CommonLib IS

  function requiredBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo <= val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end requiredBitNb;

  function counterBitNb (val : integer) return integer is
    variable powerOfTwo, bitNb : integer;
  begin
    powerOfTwo := 1;
    bitNb := 0;
    while powerOfTwo < val loop
      powerOfTwo := 2 * powerOfTwo;
      bitNb := bitNb + 1;
    end loop;
    return bitNb;
  end counterBitNb;

  function sel(Cond : BOOLEAN; If_True, If_False : integer)
                                            return integer is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : string)
                                            return string is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : std_ulogic_vector)
                                            return std_ulogic_vector is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : unsigned)
                                            return unsigned is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

  function sel(Cond : BOOLEAN; If_True, If_False : signed)
                                            return signed is
  begin
    if (Cond = TRUE) then
      return (If_True);
    else
      return (If_False);
    end if;
  end function sel;

END CommonLib;




library Common;
  use Common.CommonLib.all;

architecture RTL of serialPortReceiver is

  signal dividerCounter: unsigned(requiredBitNb(baudRateDivide-1)-1 downto 0);
  signal dividerCounterReset: std_uLogic;
  signal rxDelayed: std_uLogic;
  signal dividerCounterSynchronize: std_uLogic;
  signal rxSample: std_uLogic;
  signal rxShiftReg: std_ulogic_vector(dataBitNb-1 downto 0);
  signal rxReceiving: std_uLogic;
  signal rxDataValid: std_uLogic;
  signal rxCounter: unsigned(requiredBitNb(dataBitNb)-1 downto 0);

begin

  divide: process(reset, clock)
  begin
    if reset = '1' then
      dividerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if dividerCounterSynchronize = '1' then
        dividerCounter <= to_unsigned(baudRateDivide/2, dividerCounter'length);
      elsif dividerCounterReset = '1' then
        dividerCounter <= (others => '0');
      else
        dividerCounter <= dividerCounter + 1;
      end if;
    end if;
  end process divide;

  endOfCount: process(dividerCounter)
  begin
    if dividerCounter = baudRateDivide-1 then
      dividerCounterReset <= '1';
    else
      dividerCounterReset <= '0';
    end if;
  end process endOfCount;

  delayRx: process(reset, clock)
  begin
    if reset = '1' then
      rxDelayed <= '0';
    elsif rising_edge(clock) then
      rxDelayed <= RxD;
    end if;
  end process delayRx;

  rxSynchronize: process(RxD, rxDelayed)
  begin
    if RxD /= rxDelayed then
      dividerCounterSynchronize <= '1';
    else
      dividerCounterSynchronize <= '0';
    end if;
  end process rxSynchronize;

  rxSample <= dividerCounterReset;

  shiftReg: process(reset, clock)
  begin
    if reset = '1' then
      rxShiftReg <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        rxShiftReg(rxShiftReg'high-1 downto 0) <= rxShiftReg(rxShiftReg'high downto 1);
        rxShiftReg(rxShiftReg'high) <= RxD;
      end if;
    end if;
  end process shiftReg;

  detectReceive: process(reset, clock)
  begin
    if reset = '1' then
      rxReceiving <= '0';
      rxDataValid <= '0';
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxCounter = dataBitNb-1 then
          rxDataValid <= '1';
        elsif RxD = '0' then
          rxReceiving <= '1';
        end if;
      elsif rxDataValid = '1' then
        rxReceiving <= '0';
        rxDataValid <= '0';
      end if;
    end if;
  end process detectReceive;

  countRxBitNb: process(reset, clock)
  begin
    if reset = '1' then
      rxCounter <= (others => '0');
    elsif rising_edge(clock) then
      if rxSample = '1' then
        if rxReceiving = '1' then
          rxCounter <= rxCounter + 1;
        else
          rxCounter <= (others => '0');
        end if;
      end if;
    end if;
  end process countRxBitNb;

  dataOut <= rxShiftReg;
  dataValid <= rxDataValid;

end RTL;





-- VHDL Entity Memory.FIFO.symbol
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 09:22:34 17.06.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO IS
    GENERIC( 
        dataBitNb : positive := 8;
        depth     : positive := 16
    );
    PORT( 
        write   : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic;
        full    : OUT    std_ulogic
    );

-- Declarations

END FIFO ;





-- VHDL Entity Memory.FIFO_oneRegister.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO_oneRegister IS
    GENERIC( 
        dataBitNb : positive := 8
    );
    PORT( 
        write   : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic;
        full    : OUT    std_ulogic
    );

-- Declarations

END FIFO_oneRegister ;





architecture oneRegister of FIFO_oneRegister is

  signal dataRegister: std_ulogic_vector(dataIn'range);

begin

  writeReg: process(reset, clock)
  begin
    if reset = '1' then
      dataRegister <= (others => '0');
    elsif rising_edge(clock) then
      if write = '1' then
        dataRegister <= dataIn;
      end if;
    end if;
  end process writeReg;

  dataOut <= dataRegister;

  manageFlags: process(reset, clock)
  begin
    if reset = '1' then
      empty <= '1';
      full  <= '0';
    elsif rising_edge(clock) then
      if write = '1' then
        empty <= '0';
        full  <= '1';
      elsif read = '1' then
        empty <= '1';
        full  <= '0';
      end if;
    end if;
  end process manageFlags;

end oneRegister;





-- VHDL Entity Memory.FIFO_bram.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:15 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY FIFO_bram IS
    GENERIC( 
        dataBitNb : positive := 8;
        depth     : positive := 8
    );
    PORT( 
        write   : IN     std_ulogic;
        clock   : IN     std_ulogic;
        reset   : IN     std_ulogic;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic;
        full    : OUT    std_ulogic
    );

-- Declarations

END FIFO_bram ;





library Common;
  use Common.CommonLib.all;

architecture RTL of FIFO_bram is

  subtype register_type is std_ulogic_vector(dataIn'high downto 0);
  type memory_type is array (0 to depth-1) of register_type;

  signal writeCounter: unsigned(requiredBitNb(depth-1)-1 downto 0);
  signal readCounter: unsigned(writeCounter'range);
  signal memoryArray: memory_type;

  type fifoStateType is (
    sEmpty, sFull,
    sRead, sWrite, sWriteFirst,
    sReadWrite, sWait
  );
  signal fifoState: fifoStateType;
  signal emptyCondition, fullCondition, empty_int: std_ulogic;

begin
  ------------------------------------------------------------------------------
                                                      -- read and write counters
  updateWriteCounter: process(reset, clock)
  begin
    if reset = '1' then
      writeCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (write = '1') and  (fullCondition = '0') then
        writeCounter <= writeCounter + 1;
      end if;
    end if;
  end process updateWriteCounter;

  updateReadCounter: process(reset, clock)
  begin
    if reset = '1' then
      readCounter <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '1') and  (empty_int = '0') then
        readCounter <= readCounter + 1;
      end if;
    end if;
  end process updateReadCounter;

  ------------------------------------------------------------------------------
                                                                -- memory access
  writeMem: process(clock)
  begin
    if rising_edge(clock) then
      if (write = '1') and (fullCondition = '0') then
        memoryArray(to_integer(writeCounter)) <= dataIn;
      end if;
    end if;
  end process writeMem;

  readMem: process(reset, clock)
  begin
    if reset = '1' then
      dataOut <= (others => '0');
    elsif rising_edge(clock) then
      if (read = '0') or (empty_int = '1') then
        dataOut <= memoryArray(to_integer(readCounter));
      else
        dataOut <= memoryArray(to_integer(readCounter+1));
      end if;
    end if;
  end process readMem;

  ------------------------------------------------------------------------------
                                                                     -- controls
  emptyCondition <= '1' when
      ( (fifoState = sRead) and (writeCounter = readCounter) ) or
        (fifoState = sEmpty)
    else '0';

  fullCondition <= '1' when
      ( (fifoState = sWrite) and (writeCounter = readCounter) ) or
        (fifoState = sFull)
    else '0';


  fifoControl: process(reset, clock)
  begin
    if reset = '1' then
      fifoState <= sEmpty;
    elsif rising_edge(clock) then
      case fifoState is
        when sEmpty =>
          if write = '1' then
            fifoState <= sWriteFirst;
          end if;
        when sFull =>
          if (read = '1') then
            fifoState <= sRead;
          end if;
        when sRead =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
		      elsif emptyCondition = '1' then
            fifoState <= sEmpty;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWriteFirst =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif write = '1' then
            fifoState <= sWrite;
          elsif read = '1' then
            fifoState <= sRead;
          else
            fifoState <= sWait;
          end if;
        when sWrite =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
		      elsif fullCondition = '1' then
            fifoState <= sFull;
          elsif write = '1' then
            fifoState <= sWrite;
          else
            fifoState <= sWait;
          end if;
        when sReadWrite =>
          if (read = '0') and (write = '0') then
            fifoState <= sWait;
          elsif (read = '1') and (write = '0') then
            fifoState <= sRead;
          elsif (write = '1') and (read = '0') then
            fifoState <= sWrite;
          end if;
        when sWait =>
          if (read = '1') and (write = '1') then
            fifoState <= sReadWrite;
          elsif read = '1' then
            fifoState <= sRead;
          elsif write = '1' then
            fifoState <= sWrite;
          end if;
        when others => null;
      end case;
    end if;
  end process fifoControl;
  

  full <= '1' when 
        (fifoState = sFull) or
        (fullCondition = '1')
    else '0';

  empty_int <= '1' when
        (fifoState = sEmpty) or
        (fifoState = sWriteFirst) or
        ( (emptyCondition = '1') and (fifoState = sRead) )
    else '0';
  empty <= empty_int;
  
end RTL;




--
-- VHDL Architecture Memory.FIFO.struct
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 09:22:34 17.06.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

LIBRARY Memory;

ARCHITECTURE struct OF FIFO IS

    -- Architecture declarations

    -- Internal signal declarations


    -- Component Declarations
    COMPONENT FIFO_bram
    GENERIC (
        dataBitNb : positive := 8;
        depth     : positive := 8
    );
    PORT (
        write   : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic ;
        full    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT FIFO_oneRegister
    GENERIC (
        dataBitNb : positive := 8
    );
    PORT (
        write   : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic ;
        full    : OUT    std_ulogic 
    );
    END COMPONENT;


BEGIN

    -- Instance port mappings.

    g0: IF depth <= 1 GENERATE
    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : FIFO_oneRegister USE ENTITY Memory.FIFO_oneRegister;
    -- pragma synthesis_on

    BEGIN
        I1 : FIFO_oneRegister
            GENERIC MAP (
                dataBitNb => dataBitNb
            )
            PORT MAP (
                write   => write,
                clock   => clock,
                reset   => reset,
                dataOut => dataOut,
                read    => read,
                dataIn  => dataIn,
                empty   => empty,
                full    => full
            );
    END GENERATE g0;

    g1: IF depth > 1 GENERATE
    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : FIFO_bram USE ENTITY Memory.FIFO_bram;
    -- pragma synthesis_on

    BEGIN
        I0 : FIFO_bram
            GENERIC MAP (
                dataBitNb => dataBitNb,
                depth     => depth
            )
            PORT MAP (
                write   => write,
                clock   => clock,
                reset   => reset,
                dataOut => dataOut,
                read    => read,
                dataIn  => dataIn,
                empty   => empty,
                full    => full
            );
    END GENERATE g1;

END struct;




-- VHDL Entity RS232.serialPortTransmitter.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:45:48 08/28/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialPortTransmitter IS
    GENERIC( 
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT( 
        TxD    : OUT    std_ulogic;
        clock  : IN     std_ulogic;
        reset  : IN     std_ulogic;
        dataIn : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        send   : IN     std_ulogic;
        busy   : OUT    std_ulogic
    );

-- Declarations

END serialPortTransmitter ;





library Common;
  use Common.CommonLib.all;

architecture RTL of serialPortTransmitter is

  signal dividerCounter: unsigned(requiredBitNb(baudRateDivide)-1 downto 0);
  signal dividerCounterReset: std_uLogic;
  signal txData: std_ulogic_vector(dataBitNb-1 downto 0);
  signal send1: std_uLogic;
  signal txShiftEnable: std_uLogic;
  signal txShiftReg: std_ulogic_vector(dataBitNb+1 downto 0);
  signal txSendingByte: std_uLogic;
  signal txSendingByteAndStop: std_uLogic;

begin

  divide: process(reset, clock)
  begin
    if reset = '1' then
      dividerCounter <= (others => '0');
    elsif rising_edge(clock) then
      if dividerCounterReset = '1' then
        dividerCounter <= to_unsigned(1, dividerCounter'length);
      else
        dividerCounter <= dividerCounter + 1;
      end if;
    end if;
  end process divide;

  endOfCount: process(dividerCounter, send1)
  begin
    if dividerCounter = baudRateDivide then
      dividerCounterReset <= '1';
    elsif send1 = '1' then
      dividerCounterReset <= '1';
    else
      dividerCounterReset <= '0';
    end if;
  end process endOfCount;

  txShiftEnable <= dividerCounterReset;

  storeData: process(reset, clock)
  begin
    if reset = '1' then
      txData <= (others => '1');
    elsif rising_edge(clock) then
      if send = '1' then
        txData <= dataIn;
      end if;
    end if;
  end process storeData;

  delaySend: process(reset, clock)
  begin
    if reset = '1' then
      send1 <= '0';
    elsif rising_edge(clock) then
      send1 <= send;
    end if;
  end process delaySend;

  shiftReg: process(reset, clock)
  begin
    if reset = '1' then
      txShiftReg <= (others => '1');
    elsif rising_edge(clock) then
      if txShiftEnable = '1' then
        if send1 = '1' then
          txShiftReg <= '0' & txData & '0';
        else
          txShiftReg(txShiftReg'high-1 downto 0) <= txShiftReg(txShiftReg'high downto 1);
          txShiftReg(txShiftReg'high) <= '1';
        end if;
      end if;
    end if;
  end process shiftReg;

  txSendingByte <= '1' when (txShiftReg(txShiftReg'high downto 1) /= (txShiftReg'high downto 1 => '1'))
    else '0';

  txSendingByteAndStop <= '1' when txShiftReg /= (txShiftReg'high downto 0 => '1')
    else '0';

  TxD <= txShiftReg(0) when txSendingByte = '1' else '1';
  busy <= txSendingByteAndStop  or send1 or send;

end RTL;





--
-- VHDL Architecture RS232.serialPortFIFO.struct
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 09:23:20 17.06.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.ALL;

LIBRARY Memory;
LIBRARY RS232;

ARCHITECTURE struct OF serialPortFIFO IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL txSend      : std_ulogic;
    SIGNAL rxWord      : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL rxWordValid : std_ulogic;
    SIGNAL txFifoEmpty : std_ulogic;
    SIGNAL txWord      : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL txBusy      : std_ulogic;


    -- Component Declarations
    COMPONENT FIFO
    GENERIC (
        dataBitNb : positive := 8;
        depth     : positive := 16
    );
    PORT (
        write   : IN     std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        dataOut : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        read    : IN     std_ulogic ;
        dataIn  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        empty   : OUT    std_ulogic ;
        full    : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialPortReceiver
    GENERIC (
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT (
        RxD       : IN     std_ulogic ;
        clock     : IN     std_ulogic ;
        reset     : IN     std_ulogic ;
        dataOut   : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        dataValid : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialPortTransmitter
    GENERIC (
        dataBitNb      : positive := 8;
        baudRateDivide : positive := 2083
    );
    PORT (
        TxD    : OUT    std_ulogic ;
        clock  : IN     std_ulogic ;
        reset  : IN     std_ulogic ;
        dataIn : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        send   : IN     std_ulogic ;
        busy   : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : FIFO USE ENTITY Memory.FIFO;
    FOR ALL : serialPortReceiver USE ENTITY RS232.serialPortReceiver;
    FOR ALL : serialPortTransmitter USE ENTITY RS232.serialPortTransmitter;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 1 eb1
    process(reset, clock)
      begin
        if reset = '1' then
          txSend <= '0';
        elsif rising_edge(clock) then
          if ( (txFifoEmpty = '0') and (txBusy = '0') ) then
            txSend <= '1';
          else
            txSend <= '0';
          end if;
        end if;
      end process;
          


    -- Instance port mappings.
    I_rxFifo : FIFO
        GENERIC MAP (
            dataBitNb => dataBitNb,
            depth     => rxFifoDepth
        )
        PORT MAP (
            write   => rxWordValid,
            clock   => clock,
            reset   => reset,
            dataOut => rxData,
            read    => rxRd,
            dataIn  => rxWord,
            empty   => rxEmpty,
            full    => OPEN
        );
    I_txFifo : FIFO
        GENERIC MAP (
            dataBitNb => dataBitNb,
            depth     => txFifoDepth
        )
        PORT MAP (
            write   => txWr,
            clock   => clock,
            reset   => reset,
            dataOut => txWord,
            read    => txSend,
            dataIn  => txData,
            empty   => txFifoEmpty,
            full    => txFull
        );
    I_rx : serialPortReceiver
        GENERIC MAP (
            dataBitNb      => dataBitNb,
            baudRateDivide => baudRateDivide
        )
        PORT MAP (
            RxD       => RxD,
            clock     => clock,
            reset     => reset,
            dataOut   => rxWord,
            dataValid => rxWordValid
        );
    I_tx : serialPortTransmitter
        GENERIC MAP (
            dataBitNb      => dataBitNb,
            baudRateDivide => baudRateDivide
        )
        PORT MAP (
            TxD    => TxD,
            clock  => clock,
            reset  => reset,
            dataIn => txWord,
            send   => txSend,
            busy   => txBusy
        );

END struct;




-- VHDL Entity Poetic.uartController.symbol
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 16:12:08 08.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY uartController IS
    GENERIC( 
        dataBitNb : positive := 8
    );
    PORT( 
        clock        : IN     std_ulogic;
        reset        : IN     std_ulogic;
        rxData       : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        rxEmpty      : IN     std_ulogic;
        txFull       : IN     std_ulogic;
        consigne     : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        endOfMsg     : OUT    std_ulogic;
        newCharacter : OUT    std_ulogic;
        rxRd         : OUT    std_ulogic;
        txData       : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txWr         : OUT    std_ulogic
    );

-- Declarations

END uartController ;





--
-- VHDL Architecture Poetic.uartController.fsm
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 17:17:44 11.08.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
 
ARCHITECTURE fsm OF uartController IS

    TYPE STATE_TYPE IS (
        waitForCommand,
        dispatcher,
        S_select,
        S_receive,
        S_waitForOtherCharacter
    );
 
    -- Declare current and next state signals
    SIGNAL current_state : STATE_TYPE;
    SIGNAL next_state : STATE_TYPE;

    -- Declare any pre-registered internal signals
    SIGNAL consigne_cld : std_ulogic_vector (dataBitNb-1 DOWNTO 0);
    SIGNAL endOfMsg_cld : std_ulogic ;
    SIGNAL newCharacter_cld : std_ulogic ;
    SIGNAL rxRd_cld : std_ulogic ;
    SIGNAL txData_cld : std_ulogic_vector (dataBitNb-1 DOWNTO 0);
    SIGNAL txWr_cld : std_ulogic ;

BEGIN

    -----------------------------------------------------------------
    clocked_proc : PROCESS ( 
        clock,
        reset
    )
    -----------------------------------------------------------------
    BEGIN
        IF (reset = '1') THEN
            current_state <= waitForCommand;
            -- Default Reset Values
            consigne_cld <= (others => '0');
            endOfMsg_cld <= '0';
            newCharacter_cld <= '0';
            rxRd_cld <= '0';
            txData_cld <= (others => '0');
            txWr_cld <= '0';
        ELSIF (clock'EVENT AND clock = '1') THEN
            current_state <= next_state;

            -- Combined Actions
            CASE current_state IS
                WHEN waitForCommand => 
                    newCharacter_cld <= '0';
                    rxRd_cld <= '0';
                    consigne_cld <= (others => '0');
                    endOfMsg_cld <= '0';
                    txData_cld <= (others => '0');
                    txWr_cld <= '0';
                WHEN dispatcher => 
                    IF (rxData = X"53") THEN 
                        rxRd_cld <= '1';
                    ELSE
                        rxRd_cld <= '1';
                    END IF;
                WHEN S_select => 
                    rxRd_cld <= '0';
                    newCharacter_cld <= '0';
                    IF (rxEmpty = '0' AND rxData/=X"53") THEN 
                        rxRd_cld <= '1';
                    END IF;
                WHEN S_receive => 
                    consigne_cld <= rxData;
                    if rxData /= X"65" then
                      newCharacter_cld <= '1';
                    end if;
                    IF (rxData /= X"65") THEN 
                    ELSIF (rxData = X"65") THEN 
                        endOfMsg_cld <= '1';
                    END IF;
                WHEN S_waitForOtherCharacter => 
                    rxRd_cld <= '0';
                    newCharacter_cld <= '0';
                    IF (rxEmpty = '0') THEN 
                        rxRd_cld <= '1';
                    END IF;
                WHEN OTHERS =>
                    NULL;
            END CASE;
        END IF;
    END PROCESS clocked_proc;
 
    -----------------------------------------------------------------
    nextstate_proc : PROCESS ( 
        current_state,
        rxData,
        rxEmpty
    )
    -----------------------------------------------------------------
    BEGIN
        CASE current_state IS
            WHEN waitForCommand => 
                IF (rxEmpty = '0') THEN 
                    next_state <= dispatcher;
                ELSE
                    next_state <= waitForCommand;
                END IF;
            WHEN dispatcher => 
                IF (rxData = X"53") THEN 
                    next_state <= S_select;
                ELSE
                    next_state <= waitForCommand;
                END IF;
            WHEN S_select => 
                IF (rxEmpty = '0' AND rxData/=X"53") THEN 
                    next_state <= S_receive;
                ELSE
                    next_state <= S_select;
                END IF;
            WHEN S_receive => 
                IF (rxData /= X"65") THEN 
                    next_state <= S_waitForOtherCharacter;
                ELSIF (rxData = X"65") THEN 
                    next_state <= waitForCommand;
                ELSE
                    next_state <= S_receive;
                END IF;
            WHEN S_waitForOtherCharacter => 
                IF (rxEmpty = '0') THEN 
                    next_state <= S_receive;
                ELSE
                    next_state <= S_waitForOtherCharacter;
                END IF;
            WHEN OTHERS =>
                next_state <= waitForCommand;
        END CASE;
    END PROCESS nextstate_proc;
 
    -- Concurrent Statements
    -- Clocked output assignments
    consigne <= consigne_cld;
    endOfMsg <= endOfMsg_cld;
    newCharacter <= newCharacter_cld;
    rxRd <= rxRd_cld;
    txData <= txData_cld;
    txWr <= txWr_cld;
END fsm;




-- VHDL Entity Poetic.serialAsciiDecoder.symbol
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 16:04:54 29.06.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY serialAsciiDecoder IS
    PORT( 
        clock        : IN     std_ulogic;
        consigne     : IN     std_ulogic_vector (7 DOWNTO 0);
        endOfMsg     : IN     std_ulogic;
        newCharacter : IN     std_ulogic;
        reset        : IN     std_ulogic;
        output       : OUT    std_ulogic_vector (11 DOWNTO 0)
    );

-- Declarations

END serialAsciiDecoder ;





--
-- VHDL Architecture Poetic.serialAsciiDecoder.serialAsciiDecoder
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 10:55:13 29.06.2021
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE serialAsciiDecoder OF serialAsciiDecoder IS
  type decodeState is (
    isReceiving, endOfReceive, ready, print, increment, incrementAdder
  );
  signal mainState : decodeState;
  type t_Memory is array (0 to 11) of std_ulogic_vector(7 downto 0);
  signal r_Mem : t_Memory;
BEGIN
  decode : process(reset, clock)
    variable counterCharacter : integer;
    variable counterAdder : integer;
	variable uOutput : integer;
  begin
    if reset = '1' then
      uOutput := 0;
      output <= (others => '0');
      mainState <= ready;
      counterCharacter := 0;
      counterAdder := 0;
      for i in 0 to 11 loop
        r_Mem(i) <= (others => '0');
      end loop;
    elsif rising_edge(clock) then
      case mainState is 
        when ready =>
		  uOutput := 0;
          if newCharacter = '1' then
            r_Mem(counterCharacter) <= consigne;
            mainState <= increment;
          end if;
        when isReceiving =>
          if endOfMsg = '1' then
            mainState <= endOfReceive;
          end if;
          if newCharacter = '1' then
            mainState <= increment;
            r_Mem(counterCharacter) <= consigne;
          end if;
        when increment =>
          counterCharacter := counterCharacter + 1;
          mainState <= isReceiving;
        when endOfReceive =>
          if counterAdder = counterCharacter then
            mainState <= print;
          else
            r_Mem(counterAdder) <= (others => '0');
            mainState <= incrementAdder;
			if counterAdder /= counterCharacter - 1 then
				case r_Mem(counterAdder) is
				  when X"30" => uOutput := uOutput * 10;
				  when X"31" => uOutput := (uOutput + 1) * 10;
				  when X"32" => uOutput := (uOutput + 2) * 10;
				  when X"33" => uOutput := (uOutput + 3) * 10;
				  when X"34" => uOutput := (uOutput + 4) * 10;
				  when X"35" => uOutput := (uOutput + 5) * 10;
				  when X"36" => uOutput := (uOutput + 6) * 10;
				  when X"37" => uOutput := (uOutput + 7) * 10;
				  when X"38" => uOutput := (uOutput + 8) * 10;
				  when X"39" => uOutput := (uOutput + 9) * 10;
				  when others =>
				end case;
			else
				case r_Mem(counterAdder) is
				  when X"30" => uOutput := uOutput;
				  when X"31" => uOutput := (uOutput + 1);
				  when X"32" => uOutput := (uOutput + 2);
				  when X"33" => uOutput := (uOutput + 3);
				  when X"34" => uOutput := (uOutput + 4);
				  when X"35" => uOutput := (uOutput + 5);
				  when X"36" => uOutput := (uOutput + 6);
				  when X"37" => uOutput := (uOutput + 7);
				  when X"38" => uOutput := (uOutput + 8);
				  when X"39" => uOutput := (uOutput + 9);
				  when others =>
				end case;
			end if;
          end if;
        when incrementAdder =>
          counterAdder := counterAdder + 1;
          mainState <= endOfReceive;
        when print =>
          output <= std_ulogic_vector(to_unsigned(uOutput, output'length));
          counterCharacter := 0;
          counterAdder := 0;
          mainState <= ready;
      end case;
    end if;
  end process decode;
END ARCHITECTURE serialAsciiDecoder;





-- VHDL Entity Modulation.pwmModulator.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 16:13:13 10/29/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY pwmModulator IS
    GENERIC( 
        signalBitNb : positive := 16
    );
    PORT( 
        clock      : IN     std_ulogic;
        parallelIn : IN     unsigned (signalBitNb-1 DOWNTO 0);
        reset      : IN     std_ulogic;
        serialOut  : OUT    std_ulogic
    );

-- Declarations

END pwmModulator ;





ARCHITECTURE RTL OF pwmModulator IS

  signal sawtooth : unsigned(parallelIn'range);

BEGIN
  ------------------------------------------------------------------------------
                                                              -- sawtooth signal
  buildSawtooth: process(clock, reset)
  begin
    if reset = '1' then
      sawtooth <= (others => '0');
    elsif rising_edge(clock) then
      sawtooth <= sawtooth + 1;
    end if;
  end process buildSawtooth;

  ------------------------------------------------------------------------------
                                                    -- compare with input signal
  buildPwm: process(sawtooth, parallelIn)
  begin
    if parallelIn > sawtooth then
      serialOut <= '1';
    else
      serialOut <= '0';
    end if;
  end process buildPwm;

END ARCHITECTURE RTL;




LIBRARY ieee;
USE ieee.std_logic_1164.all;

PACKAGE gates IS

--  constant gateDelay: time := 1 ns;
  constant gateDelay: time := 0.1 ns;

END gates;




-- VHDL Entity Gates.logic1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:13 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY logic1 IS
    PORT( 
        logic_1 : OUT    std_uLogic
    );

-- Declarations

END logic1 ;





ARCHITECTURE sim OF logic1 IS
BEGIN
  logic_1 <= '1';
END sim;




-- VHDL Entity Poetic.DAC.symbol
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 10:25:36 10.08.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY DAC IS
    GENERIC( 
        dacBitNb   : positive := 8;
        dacChBitNb : positive := 2;
        dacOpBitNb : positive := 2
    );
    PORT( 
        SCLK   : IN     std_ulogic;
        clock  : IN     std_ulogic;
        dacSel : IN     std_ulogic_vector (dacChBitNb-1 DOWNTO 0);
        data   : IN     std_ulogic_vector (dacBitNb-1 DOWNTO 0);
        mode   : IN     std_ulogic_vector (dacOpBitNb-1 DOWNTO 0);
        reset  : IN     std_ulogic;
        send   : IN     std_ulogic;
        Dout   : OUT    std_ulogic;
        Sync_n : OUT    std_ulogic
    );

-- Declarations

END DAC ;





--
-- VHDL Architecture Poetic.DAC.DAC124S085
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 09:21:02 18.06.2021
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE DAC124S085 OF DAC IS
  constant numberOfDataToSend : integer := 12;
  signal memSCLK, risingSCLK : std_ulogic;
  signal masterWr : std_ulogic;
  signal masterData : std_ulogic_vector(dacBitNb+dacChBitNb+dacOpBitNb-1 DOWNTO 0);
  type transmitState is(
    waitForATransmission, sendData, sendLowSync, sendHighSync, sendZero
  );
  signal mainState : transmitState;
BEGIN
  concatenate : process (reset, clock)
  begin
    if reset = '1' then
      masterData <= (others => '0');
      masterWr <= '0';
    elsif rising_edge(clock) then
    masterWr <= '0';
      if send = '1' then
        masterData <= dacSel & mode & data;
        masterWr <= '1';
      end if;
    end if;
  end process concatenate;
  
  transmit : process (reset, clock)
  variable decounter : integer;
  variable counter : integer;
  begin
    if reset = '1' then
      mainState <= waitForATransmission;
      decounter := masterData'length-1;
      Sync_n <= '1';
      Dout <= '0';
	  counter := 0;
    elsif rising_edge(clock) then
      case mainState is
        when waitForATransmission =>
          if masterWr = '1' then
            mainState <= sendLowSync;
          end if;
        when sendData =>
          if risingSCLK = '1' then
            decounter := decounter - 1;
            Dout <= masterData(decounter);
            if decounter = 0 then
              mainState <= sendZero;
            end if;
          end if;
        when sendLowSync =>
          if risingSCLK = '1' then
            Sync_n <= '0';
            Dout <= masterData(decounter);
            mainState <= sendData;
          end if;
        when sendHighSync =>
          decounter := masterData'length-1;
          counter := 0;
          if risingSCLK = '1' then
            Sync_n <= '1';
            mainState <= waitForATransmission;
          end if;
		when sendZero =>
		  if risingSCLK = '1' then
		    Dout <= '0';
			counter := counter + 1;
      end if;
			if counter >= numberOfDataToSend - dacBitNb then
			  mainState <= sendHighSync;
		  end if;
      end case;
    end if;
  end process transmit;
  
  detectRisingSCLK : process (reset, clock)
  begin
    if reset = '1' then
      memSCLK <= '0';
      risingSCLK <= '0';
    elsif rising_edge(clock) then
      risingSCLK <= '0';
      if memSCLK = '0' AND SCLK = '1' then
        risingSCLK <= '1';
        memSCLK <= SCLK;
      else
        memSCLK <= SCLK;
      end if;
    end if;
  end process detectRisingSCLK;
END ARCHITECTURE DAC124S085;





-- VHDL Entity Poetic.regulator.symbol
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 13:29:47 06.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY regulator IS
    GENERIC( 
        pidBitNb : positive := 12
    );
    PORT( 
        Setval        : IN     std_ulogic_vector (pidBitNb-1 DOWNTO 0);
        adc_data      : IN     std_ulogic_vector (pidBitNb-1 DOWNTO 0);
        clock         : IN     std_ulogic;
        kd_sw         : IN     std_ulogic;
        ki_sw         : IN     std_ulogic;
        kp_sw         : IN     std_ulogic;
        on_off_switch : IN     std_ulogic;
        reset         : IN     std_ulogic;
        update        : IN     std_ulogic;
        output        : OUT    unsigned (pidBitNb-1 DOWNTO 0)
    );

-- Declarations

END regulator ;





--
-- VHDL Architecture Poetic.regulator.PDI3
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 20:04:32 22.07.2021
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE PDI3 OF regulator IS
  type State is (
    ready, calculateNewError,calculatePID, checkOverFlow, print
  );
  constant Kp : integer := 4;
  constant Ki : integer := 3;
  signal mainState : State;
  signal updatePID : std_ulogic;
  signal PIDHasBeenUpdate : std_ulogic;
  signal error : signed(pidBitNb DOWNTO 0);
  signal error_sum : signed(pidBitNb+20 DOWNTO 0); --BIG NUMBER
  signal pidValue : signed(pidBitNb+5+1 DOWNTO 0);
  signal p : signed(pidBitNb+5 DOWNTO 0);
  signal i : signed(pidBitNb+5 DOWNTO 0);
  signal d : signed(pidBitNb+5 DOWNTO 0);
  signal sOutput : unsigned(pidBitNb-1 DOWNTO 0);
BEGIN
  process (clock, reset)
  begin
    if reset = '1' then
      output <= (others => '0');
      mainState <= ready;
      error <= (others => '0');
      p <= (others => '0');
      i <= (others => '0');
      d <= (others => '0');
      pidValue <= (others => '0');
      sOutput <= (others => '0');
      PIDHasBeenUpdate <= '0';
      error_sum <= (others => '0');
    elsif rising_edge(clock) then
      case mainState is 
        when ready =>
          mainState <= calculateNewError;
        when calculateNewError =>
          error <= signed(resize(unsigned(Setval), error'length)) - signed(resize(unsigned(adc_data), error'length));
          if updatePID = '1' AND ki_sw = '1' then
            error_sum <= error_sum + error;
            PIDHasBeenUpdate <= '1';
          else
            PIDHasBeenUpdate <= '0';
          end if;
          mainState <= calculatePID;
        when calculatePID =>
          if kp_sw = '1' then
            p <= resize(Kp * error, p'length);
          end if;
          if ki_sw = '1' then
            i <= resize(Ki*shift_right(error_sum,0), i'length);
          end if;
          pidValue <= resize(p, pidValue'length) + resize(i, pidValue'length) + resize(d, pidValue'length);
          mainState <= checkOverFlow;
        when checkOverFlow =>
          if pidValue > 4095 then
            sOutput <= (others => '1');
          elsif pidValue < 0 then
            sOutput <= (others => '0');
          else
            sOutput <= resize(unsigned(pidValue), sOutput'length);
          end if;
          mainState <= print;
        when print => 
          mainState <= ready;
          output <= sOutput;
      end case;
    end if;
  end process;
  
  process (clock, reset)
    variable counter : integer := 0;   
  begin
    if reset = '1' then
      counter := 0;
      updatePID <= '0';
    elsif rising_edge(clock) then
      counter := counter + 1;
      if PIDHasBeenUpdate = '1' then
        updatePID <= '0';
      end if;
      if counter > 100000 then
        updatePID <= '1';
        counter := 0;
      end if;
    end if;
  end process;
END ARCHITECTURE PDI3;





-- VHDL Entity Gates.and2inv1.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:34:52 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY and2inv1 IS
    GENERIC( 
        delay : time := gateDelay
    );
    PORT( 
        in1  : IN     std_uLogic;
        in2  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END and2inv1 ;





ARCHITECTURE sim OF and2inv1 IS
BEGIN
  out1 <= in1 and (not in2) after delay;
END ARCHITECTURE sim;




-- VHDL Entity Poetic.clockGenerator.symbol
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 11:08:27 30.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY clockGenerator IS
    GENERIC( 
        counterBitNb : integer := 12;
        frequencyIn  : integer := 100000000;
        frequencyOut : integer := 20000000
    );
    PORT( 
        clock    : IN     std_ulogic;
        enable   : IN     std_ulogic;
        reset    : IN     std_ulogic;
        clockOut : OUT    std_ulogic
    );

-- Declarations

END clockGenerator ;





--
-- VHDL Architecture Poetic.clockGenerator.clockDivider
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 11:15:13 17.06.2021
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE clockDivider OF clockGenerator IS
  constant countValue : integer := integer(real(integer(real(frequencyIn) / real((frequencyOut)))) / 2.0);
  signal counter : unsigned(counterBitNb-1 DOWNTO 0);
  signal clockOut_int : std_ulogic;
BEGIN
  clockOut <= clockOut_int;
  increment : process(reset, clock)
  begin
    if reset = '1' then
	  clockOut_int <= '0';
      counter <= (others => '0');
      counter(counter'low) <= '1';
    elsif rising_edge(clock) then
      if enable = '1' then
        counter <= counter + 1;
          if (counter >= countValue) then
            clockOut_int <= not clockOut_int;
            counter <= (others => '0');
            counter(counter'low) <= '1';
          end if;
      else
        clockOut_int <= '0';
      end if;
    end if;
  end process increment;
END ARCHITECTURE clockDivider;





-- VHDL Entity Gates.logic0.symbol
--
-- Created:
--          by - silvan.zahno.UNKNOWN (WE6996)
--          at - 14:35:14 11.09.2019
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
LIBRARY gates;
  USE gates.gates.all;

ENTITY logic0 IS
    PORT( 
        logic_0 : OUT    std_uLogic
    );

-- Declarations

END logic0 ;





ARCHITECTURE sim OF logic0 IS
BEGIN
  logic_0 <= '0';
END sim;




-- VHDL Entity Board.DFF.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:05 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY DFF IS
    PORT( 
        CLK : IN     std_uLogic;
        CLR : IN     std_uLogic;
        D   : IN     std_uLogic;
        Q   : OUT    std_uLogic
    );

-- Declarations

END DFF ;





ARCHITECTURE sim OF DFF IS
BEGIN

  process(clk, clr)
  begin
    if clr = '1' then
      q <= '0';
    elsif rising_edge(clk) then
      q <= d;
    end if;
  end process;

END ARCHITECTURE sim;





-- VHDL Entity Poetic.ADC.symbol
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 16:51:57 30.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY ADC IS
    GENERIC( 
        adcBitNb    : integer := 12;
        highSpeedEn : natural := 0
    );
    PORT( 
        SCLK   : IN     std_ulogic;
        SDO    : IN     std_ulogic;
        clock  : IN     std_ulogic;
        enable : IN     std_ulogic;
        reset  : IN     std_ulogic;
        CS_n   : OUT    std_ulogic;
        Data   : OUT    std_ulogic_vector (adcBitNb-1 DOWNTO 0)
    );

-- Declarations

END ADC ;





--
-- VHDL Architecture Poetic.ADC.ads7886_decoder
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 14:09:37 17.06.2021
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE ads7886_decoder OF ADC IS
  type decodeState is (
    sendLowCS, waitForData, readData, sendHighCS, ready, print
  );
  signal mainState : decodeState;
  signal memSCLK, risingSCLK : std_ulogic;
  signal counterWaitData : unsigned(1 DOWNTO 0);
  signal counterReadData : unsigned(10 DOWNTO 0);
  signal dataReg : unsigned(adcBitNb-1 DOWNTO 0);
BEGIN
  decode : process(reset, clock)
    variable counterTq : integer;
  begin
    if reset = '1' then
      counterTq := 0;
      mainState <= ready;
      Data <= (others => '0');
      CS_n <= '1';
      counterReadData <= (others => '0');
      counterWaitData <= (others => '0');
      dataReg <= (others => '0');
    elsif rising_edge(clock) then
      case mainState is 
        when ready =>
          if enable = '1' AND risingSCLK = '1' then
            counterTq := 0;
            mainState <= sendLowCS;
          end if;
        when sendLowCS =>
          CS_n <= '0';
          mainState <= waitForData;
        when waitForData =>
          if risingSCLK = '1' then
            counterWaitData <= counterWaitData +1;
            if counterWaitData = 3 then
              mainState <= readData;
              counterWaitData <= (others => '0');
            end if;
          end if;
        when readData =>
          if risingSCLK = '1' then
            counterReadData <= counterReadData + 1;
            dataReg <= shift_left(dataReg, 1);
            dataReg(dataReg'low) <= SDO;
            if (counterReadData = adcBitNb-1) then
              counterReadData <= (others => '0');
              mainState <= print;
            end if;
          end if;
        when print =>
          Data <= std_ulogic_vector(dataReg);
          mainState <= sendHighCS;
        when sendHighCS =>
            if risingSCLK = '1' then
              CS_n <= '1';
              counterTq := counterTq + 1;
              if counterTq = 2 then
                mainState <= ready;
              end if;
            end if;
      end case;
    end if;
  end process decode;
  
  detectRisingSCLK : process (reset, clock)
  begin
    if reset = '1' then
      memSCLK <= '0';
      risingSCLK <= '0';
    elsif rising_edge(clock) then
      risingSCLK <= '0';
      if memSCLK = '0' AND SCLK = '1' then
        risingSCLK <= '1';
        memSCLK <= SCLK;
      else
        memSCLK <= SCLK;
      end if;
    end if;
  end process detectRisingSCLK;
END ARCHITECTURE ads7886_decoder;





-- VHDL Entity Poetic.BLDCController.symbol
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 16:20:14 23.07.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;

ENTITY BLDCController IS
    PORT( 
        Hall_A : IN     std_ulogic;
        Hall_B : IN     std_ulogic;
        Hall_C : IN     std_ulogic;
        PWM_in : IN     std_ulogic;
        clock  : IN     std_ulogic;
        reset  : IN     std_ulogic;
        Sa_bot : OUT    std_ulogic;
        Sa_top : OUT    std_ulogic;
        Sb_bot : OUT    std_ulogic;
        Sb_top : OUT    std_ulogic;
        Sc_bot : OUT    std_ulogic;
        Sc_top : OUT    std_ulogic
    );

-- Declarations

END BLDCController ;





--
-- VHDL Architecture Poetic.BLDCController.BLDC
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 11:42:58 22.07.2021
--
-- using Mentor Graphics HDL Designer(TM) 2019.2 (Build 5)
--
ARCHITECTURE BLDC OF BLDCController IS
BEGIN
  logic : process (Hall_A, Hall_B, Hall_C, PWM_in)
  variable hallReg : std_ulogic_vector(2 DOWNTO 0);
  begin
    hallReg := Hall_A & Hall_B & Hall_C;
    case hallReg is
      when "001" => --Sa_top 1 & Sb_bot 1
        Sa_top <= PWM_in;
        Sa_bot <= '0';
        Sb_top <= '0';
        Sb_bot <= PWM_in;
        Sc_top <= '0';
        Sc_bot <= '0';
      when "101" => --Sa_top 1 & Sc_bot 1
        Sa_top <= PWM_in;
        Sa_bot <= '0';
        Sb_top <= '0';
        Sb_bot <= '0';
        Sc_top <= '0';
        Sc_bot <= PWM_in;
      when "100" =>
        Sa_top <= '0';
        Sa_bot <= '0';
        Sb_top <= PWM_in;
        Sb_bot <= '0';
        Sc_top <= '0';
        Sc_bot <= PWM_in;
      when "110" =>
        Sa_top <= '0';
        Sa_bot <= PWM_in;
        Sb_top <= PWM_in;
        Sb_bot <= '0';
        Sc_top <= '0';
        Sc_bot <= '0';
      when "010" =>
        Sa_top <= '0';
        Sa_bot <= PWM_in;
        Sb_top <= '0';
        Sb_bot <= '0';
        Sc_top <= PWM_in;
        Sc_bot <= '0';      
      when "011" =>
        Sa_top <= '0';
        Sa_bot <= '0';
        Sb_top <= '0';
        Sb_bot <= PWM_in;
        Sc_top <= PWM_in;
        Sc_bot <= '0'; 
      when others =>
        Sa_top <= '0';
        Sa_bot <= '0';
        Sb_top <= '0';
        Sb_bot <= '0';
        Sc_top <= '0';
        Sc_bot <= '0'; 
    end case;
  end process logic;
END ARCHITECTURE BLDC;



--
-- VHDL Architecture Poetic.SimplePoeticBLDC.struct
--
-- Created:
--          by - jean.nanchen.UNKNOWN (WEA30407)
--          at - 20:14:38 17.08.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
USE gates.gates.all;

LIBRARY Board;
LIBRARY Modulation;
LIBRARY Poetic;
LIBRARY RS232;

ARCHITECTURE struct OF SimplePoeticBLDC IS

    -- Architecture declarations

    -- Internal signal declarations
    SIGNAL Q              : std_uLogic;
    SIGNAL clockOut       : std_ulogic;
    SIGNAL consigne       : std_ulogic_vector(pidBitNb-1 DOWNTO 0);
    SIGNAL dacSel         : std_ulogic_vector(dacChBitNb-1 DOWNTO 0);
    SIGNAL endOfMsg       : std_ulogic;
    SIGNAL in1            : std_uLogic;
    SIGNAL logic_0        : std_uLogic;
    SIGNAL logic_1        : std_uLogic;
    SIGNAL mode           : std_ulogic_vector(dacOpBitNb-1 DOWNTO 0);
    SIGNAL newCharacter   : std_ulogic;
    SIGNAL out1           : std_uLogic;
    SIGNAL output         : unsigned(pidBitNb-1 DOWNTO 0);
    SIGNAL rxData         : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL rxEmpty        : std_ulogic;
    SIGNAL rxRd           : std_ulogic;
    SIGNAL serialConsigne : std_ulogic_vector(dataBitNb-1 DOWNTO 0);
    SIGNAL serialOut      : std_ulogic;
    SIGNAL speed          : std_ulogic_vector(11 DOWNTO 0);
    SIGNAL txFull         : std_ulogic;

    -- Implicit buffer signal declarations
    SIGNAL ADC_SCLK_internal  : std_ulogic;
    SIGNAL DAC0_SCLK_internal : std_ulogic;


    -- Component Declarations
    COMPONENT DFF
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT and2inv1
    GENERIC (
        delay : time := gateDelay
    );
    PORT (
        in1  : IN     std_uLogic ;
        in2  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic0
    PORT (
        logic_0 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT logic1
    PORT (
        logic_1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT pwmModulator
    GENERIC (
        signalBitNb : positive := 16
    );
    PORT (
        clock      : IN     std_ulogic ;
        parallelIn : IN     unsigned (signalBitNb-1 DOWNTO 0);
        reset      : IN     std_ulogic ;
        serialOut  : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT ADC
    GENERIC (
        adcBitNb    : integer := 12;
        highSpeedEn : natural := 0
    );
    PORT (
        SCLK   : IN     std_ulogic ;
        SDO    : IN     std_ulogic ;
        clock  : IN     std_ulogic ;
        enable : IN     std_ulogic ;
        reset  : IN     std_ulogic ;
        CS_n   : OUT    std_ulogic ;
        Data   : OUT    std_ulogic_vector (adcBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT BLDCController
    PORT (
        Hall_A : IN     std_ulogic ;
        Hall_B : IN     std_ulogic ;
        Hall_C : IN     std_ulogic ;
        PWM_in : IN     std_ulogic ;
        clock  : IN     std_ulogic ;
        reset  : IN     std_ulogic ;
        Sa_bot : OUT    std_ulogic ;
        Sa_top : OUT    std_ulogic ;
        Sb_bot : OUT    std_ulogic ;
        Sb_top : OUT    std_ulogic ;
        Sc_bot : OUT    std_ulogic ;
        Sc_top : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT DAC
    GENERIC (
        dacBitNb   : positive := 8;
        dacChBitNb : positive := 2;
        dacOpBitNb : positive := 2
    );
    PORT (
        SCLK   : IN     std_ulogic ;
        clock  : IN     std_ulogic ;
        dacSel : IN     std_ulogic_vector (dacChBitNb-1 DOWNTO 0);
        data   : IN     std_ulogic_vector (dacBitNb-1 DOWNTO 0);
        mode   : IN     std_ulogic_vector (dacOpBitNb-1 DOWNTO 0);
        reset  : IN     std_ulogic ;
        send   : IN     std_ulogic ;
        Dout   : OUT    std_ulogic ;
        Sync_n : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT clockGenerator
    GENERIC (
        counterBitNb : integer := 12;
        frequencyIn  : integer := 100000000;
        frequencyOut : integer := 20000000
    );
    PORT (
        clock    : IN     std_ulogic ;
        enable   : IN     std_ulogic ;
        reset    : IN     std_ulogic ;
        clockOut : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT regulator
    GENERIC (
        pidBitNb : positive := 12
    );
    PORT (
        Setval        : IN     std_ulogic_vector (pidBitNb-1 DOWNTO 0);
        adc_data      : IN     std_ulogic_vector (pidBitNb-1 DOWNTO 0);
        clock         : IN     std_ulogic ;
        kd_sw         : IN     std_ulogic ;
        ki_sw         : IN     std_ulogic ;
        kp_sw         : IN     std_ulogic ;
        on_off_switch : IN     std_ulogic ;
        reset         : IN     std_ulogic ;
        update        : IN     std_ulogic ;
        output        : OUT    unsigned (pidBitNb-1 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT serialAsciiDecoder
    PORT (
        clock        : IN     std_ulogic ;
        consigne     : IN     std_ulogic_vector (7 DOWNTO 0);
        endOfMsg     : IN     std_ulogic ;
        newCharacter : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        output       : OUT    std_ulogic_vector (11 DOWNTO 0)
    );
    END COMPONENT;
    COMPONENT uartController
    GENERIC (
        dataBitNb : positive := 8
    );
    PORT (
        clock        : IN     std_ulogic ;
        reset        : IN     std_ulogic ;
        rxData       : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        rxEmpty      : IN     std_ulogic ;
        txFull       : IN     std_ulogic ;
        consigne     : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        endOfMsg     : OUT    std_ulogic ;
        newCharacter : OUT    std_ulogic ;
        rxRd         : OUT    std_ulogic ;
        txData       : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txWr         : OUT    std_ulogic 
    );
    END COMPONENT;
    COMPONENT serialPortFIFO
    GENERIC (
        baudRateDivide : positive := 2083;
        dataBitNb      : positive := 8;
        txFifoDepth    : positive := 8;
        rxFifoDepth    : positive := 8
    );
    PORT (
        RxD     : IN     std_ulogic ;
        TxD     : OUT    std_ulogic ;
        clock   : IN     std_ulogic ;
        reset   : IN     std_ulogic ;
        rxEmpty : OUT    std_ulogic ;
        rxRd    : IN     std_ulogic ;
        rxData  : OUT    std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txData  : IN     std_ulogic_vector (dataBitNb-1 DOWNTO 0);
        txFull  : OUT    std_ulogic ;
        txWr    : IN     std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : ADC USE ENTITY Poetic.ADC;
    FOR ALL : BLDCController USE ENTITY Poetic.BLDCController;
    FOR ALL : DAC USE ENTITY Poetic.DAC;
    FOR ALL : DFF USE ENTITY Board.DFF;
    FOR ALL : and2inv1 USE ENTITY Gates.and2inv1;
    FOR ALL : clockGenerator USE ENTITY Poetic.clockGenerator;
    FOR ALL : logic0 USE ENTITY Gates.logic0;
    FOR ALL : logic1 USE ENTITY Gates.logic1;
    FOR ALL : pwmModulator USE ENTITY Modulation.pwmModulator;
    FOR ALL : regulator USE ENTITY Poetic.regulator;
    FOR ALL : serialAsciiDecoder USE ENTITY Poetic.serialAsciiDecoder;
    FOR ALL : serialPortFIFO USE ENTITY RS232.serialPortFIFO;
    FOR ALL : uartController USE ENTITY Poetic.uartController;
    -- pragma synthesis_on


BEGIN

    -- Instance port mappings.
    U_15 : DFF
        PORT MAP (
            CLK => clock,
            CLR => reset,
            D   => clockOut,
            Q   => Q
        );
    U_11 : and2inv1
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => in1,
            in2  => txFull,
            out1 => out1
        );
    U_16 : and2inv1
        GENERIC MAP (
            delay => gateDelay
        )
        PORT MAP (
            in1  => clockOut,
            in2  => Q,
            out1 => in1
        );
    U_2 : logic0
        PORT MAP (
            logic_0 => logic_0
        );
    U_4 : logic0
        PORT MAP (
            logic_0 => dacSel(1)
        );
    U_5 : logic0
        PORT MAP (
            logic_0 => dacSel(0)
        );
    U_6 : logic0
        PORT MAP (
            logic_0 => mode(0)
        );
    U_14 : logic0
        PORT MAP (
            logic_0 => ledState_0
        );
    U_0 : logic1
        PORT MAP (
            logic_1 => logic_1
        );
    U_7 : logic1
        PORT MAP (
            logic_1 => mode(1)
        );
    I43 : pwmModulator
        GENERIC MAP (
            signalBitNb => 12
        )
        PORT MAP (
            clock      => clock,
            parallelIn => output,
            reset      => reset,
            serialOut  => serialOut
        );
    U_17 : ADC
        GENERIC MAP (
            adcBitNb    => 12,
            highSpeedEn => 0
        )
        PORT MAP (
            SCLK   => ADC_SCLK_internal,
            SDO    => ADC0_SDO,
            clock  => clock,
            enable => logic_1,
            reset  => reset,
            CS_n   => ADC0_CS,
            Data   => speed
        );
    U_9 : BLDCController
        PORT MAP (
            Hall_A => Hall_A,
            Hall_B => Hall_B,
            Hall_C => Hall_C,
            PWM_in => serialOut,
            clock  => clock,
            reset  => reset,
            Sa_bot => Sa_bot,
            Sa_top => Sa_top,
            Sb_bot => Sb_bot,
            Sb_top => Sb_top,
            Sc_bot => Sc_bot,
            Sc_top => Sc_top
        );
    U_1 : DAC
        GENERIC MAP (
            dacBitNb   => 8,
            dacChBitNb => 2,
            dacOpBitNb => 2
        )
        PORT MAP (
            SCLK   => DAC0_SCLK_internal,
            clock  => clock,
            dacSel => dacSel,
            data   => speed(11 DOWNTO 4),
            mode   => mode,
            reset  => reset,
            send   => logic_1,
            Dout   => DAC0_SDO,
            Sync_n => DAC0_SYNC
        );
    U_3 : clockGenerator
        GENERIC MAP (
            counterBitNb => 10,
            frequencyIn  => 100000000,
            frequencyOut => 20000000
        )
        PORT MAP (
            clock    => clock,
            enable   => logic_1,
            reset    => reset,
            clockOut => DAC0_SCLK_internal
        );
    U_12 : clockGenerator
        GENERIC MAP (
            counterBitNb => 30,
            frequencyIn  => 100000000,
            frequencyOut => 1
        )
        PORT MAP (
            clock    => clock,
            enable   => logic_1,
            reset    => reset,
            clockOut => clockOut
        );
    U_13 : clockGenerator
        GENERIC MAP (
            counterBitNb => 30,
            frequencyIn  => 100000000,
            frequencyOut => 1
        )
        PORT MAP (
            clock    => clock,
            enable   => logic_1,
            reset    => reset,
            clockOut => ledState_1
        );
    U_18 : clockGenerator
        GENERIC MAP (
            counterBitNb => 30,
            frequencyIn  => 100000000,
            frequencyOut => 20000000
        )
        PORT MAP (
            clock    => clock,
            enable   => logic_1,
            reset    => reset,
            clockOut => ADC_SCLK_internal
        );
    U_10 : regulator
        GENERIC MAP (
            pidBitNb => 12
        )
        PORT MAP (
            Setval        => consigne,
            adc_data      => speed,
            clock         => clock,
            kd_sw         => D,
            ki_sw         => I,
            kp_sw         => P,
            on_off_switch => enable,
            reset         => reset,
            update        => logic_0,
            output        => output
        );
    I23 : serialAsciiDecoder
        PORT MAP (
            clock        => clock,
            consigne     => serialConsigne,
            endOfMsg     => endOfMsg,
            newCharacter => newCharacter,
            reset        => reset,
            output       => consigne
        );
    I22 : uartController
        GENERIC MAP (
            dataBitNb => 8
        )
        PORT MAP (
            clock        => clock,
            reset        => reset,
            rxData       => rxData,
            rxEmpty      => rxEmpty,
            txFull       => txFull,
            consigne     => serialConsigne,
            endOfMsg     => endOfMsg,
            newCharacter => newCharacter,
            rxRd         => rxRd,
            txData       => OPEN,
            txWr         => OPEN
        );
    I0 : serialPortFIFO
        GENERIC MAP (
            baudRateDivide => 10417,
            dataBitNb      => 8,
            txFifoDepth    => 8,
            rxFifoDepth    => 1
        )
        PORT MAP (
            RxD     => USB_TX,
            TxD     => USB_RX,
            clock   => clock,
            reset   => reset,
            rxEmpty => rxEmpty,
            rxRd    => rxRd,
            rxData  => rxData,
            txData  => speed(11 DOWNTO 4),
            txFull  => txFull,
            txWr    => out1
        );

    -- Implicit buffered output assignments
    ADC_SCLK  <= ADC_SCLK_internal;
    DAC0_SCLK <= DAC0_SCLK_internal;

END struct;




-- VHDL Entity Board.inverterIn.symbol
--
-- Created:
--          by - francois.francois (Aphelia)
--          at - 13:07:14 02/19/19
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY inverterIn IS
    PORT( 
        in1  : IN     std_uLogic;
        out1 : OUT    std_uLogic
    );

-- Declarations

END inverterIn ;





ARCHITECTURE sim OF inverterIn IS
BEGIN

  out1 <= NOT in1;

END ARCHITECTURE sim;





--
-- VHDL Architecture Board.poetic_circuit.studentVersion
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 16:09:36 12.08.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
LIBRARY gates;
USE gates.gates.all;

LIBRARY Board;
LIBRARY Poetic;

ARCHITECTURE studentVersion OF poetic_circuit IS

    -- Architecture declarations
    constant signalBitNb: positive := 16;
    constant phaseBitNb: positive := 17;
    constant stepX: positive := 2;
    constant stepY: positive := 3;

    -- Internal signal declarations
    SIGNAL logic1      : std_uLogic;
    SIGNAL reset       : std_ulogic;
    SIGNAL resetSnch_N : std_ulogic;
    SIGNAL resetSynch  : std_ulogic;


    -- Component Declarations
    COMPONENT DFF
    PORT (
        CLK : IN     std_uLogic ;
        CLR : IN     std_uLogic ;
        D   : IN     std_uLogic ;
        Q   : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT inverterIn
    PORT (
        in1  : IN     std_uLogic ;
        out1 : OUT    std_uLogic 
    );
    END COMPONENT;
    COMPONENT SimplePoeticBLDC
    GENERIC (
        pidBitNb   : positive := 12;
        dacBitNb   : positive := 8;
        dacopBitNb : positive := 2;
        dacchBitNb : positive := 2;
        dataBitNb  : positive := 8
    );
    PORT (
        ADC0_SDO   : IN     std_ulogic ;
        D          : IN     std_ulogic ;
        Hall_A     : IN     std_ulogic ;
        Hall_B     : IN     std_ulogic ;
        Hall_C     : IN     std_ulogic ;
        I          : IN     std_ulogic ;
        P          : IN     std_ulogic ;
        USB_TX     : IN     std_ulogic ;
        clock      : IN     std_ulogic ;
        enable     : IN     std_ulogic ;
        reset      : IN     std_ulogic ;
        ADC0_CS    : OUT    std_ulogic ;
        ADC_SCLK   : OUT    std_ulogic ;
        DAC0_SCLK  : OUT    std_ulogic ;
        DAC0_SDO   : OUT    std_ulogic ;
        DAC0_SYNC  : OUT    std_ulogic ;
        Sa_bot     : OUT    std_ulogic ;
        Sa_top     : OUT    std_ulogic ;
        Sb_bot     : OUT    std_ulogic ;
        Sb_top     : OUT    std_ulogic ;
        Sc_bot     : OUT    std_ulogic ;
        Sc_top     : OUT    std_ulogic ;
        USB_RX     : OUT    std_ulogic ;
        ledState_0 : OUT    std_ulogic ;
        ledState_1 : OUT    std_ulogic 
    );
    END COMPONENT;

    -- Optional embedded configurations
    -- pragma synthesis_off
    FOR ALL : DFF USE ENTITY Board.DFF;
    FOR ALL : SimplePoeticBLDC USE ENTITY Poetic.SimplePoeticBLDC;
    FOR ALL : inverterIn USE ENTITY Board.inverterIn;
    -- pragma synthesis_on


BEGIN
    -- Architecture concurrent statements
    -- HDL Embedded Text Block 4 eb4
    logic1 <= '1';


    -- Instance port mappings.
    I_dff : DFF
        PORT MAP (
            CLK => clock,
            CLR => reset,
            D   => logic1,
            Q   => resetSnch_N
        );
    I_inv1 : inverterIn
        PORT MAP (
            in1  => reset_N,
            out1 => reset
        );
    I_inv2 : inverterIn
        PORT MAP (
            in1  => resetSnch_N,
            out1 => resetSynch
        );
    I0 : SimplePoeticBLDC
        GENERIC MAP (
            pidBitNb   => 12,
            dacBitNb   => 8,
            dacopBitNb => 2,
            dacchBitNb => 2,
            dataBitNb  => 8
        )
        PORT MAP (
            ADC0_SDO   => ADC0_SDO,
            D          => logic1,
            Hall_A     => Hall_A,
            Hall_B     => Hall_B,
            Hall_C     => Hall_C,
            I          => logic1,
            P          => logic1,
            USB_TX     => USB_TX,
            clock      => clock,
            enable     => logic1,
            reset      => resetSynch,
            ADC0_CS    => ADC0_CS,
            ADC_SCLK   => ADC_SCLK,
            DAC0_SCLK  => DAC_SCLK,
            DAC0_SDO   => DAC_SDO,
            DAC0_SYNC  => DAC_SYNC,
            Sa_bot     => Sa_bot,
            Sa_top     => Sa_top,
            Sb_bot     => Sb_bot,
            Sb_top     => Sb_top,
            Sc_bot     => Sc_bot,
            Sc_top     => Sc_top,
            USB_RX     => USB_RX,
            ledState_0 => LED0_0,
            ledState_1 => LED0_1
        );

END studentVersion;




