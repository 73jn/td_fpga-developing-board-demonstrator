--
-- VHDL Architecture Poetic.uartController.fsm
--
-- Created:
--          by - jeann.UNKNOWN (DESKTOP-V46KISN)
--          at - 17:17:44 11.08.2021
--
-- Generated by Mentor Graphics' HDL Designer(TM) 2019.2 (Build 5)
--
LIBRARY ieee;
  USE ieee.std_logic_1164.all;
  USE ieee.numeric_std.all;
 
ARCHITECTURE fsm OF uartController IS

    TYPE STATE_TYPE IS (
        waitForCommand,
        dispatcher,
        S_select,
        S_receive,
        S_waitForOtherCharacter
    );
 
    -- Declare current and next state signals
    SIGNAL current_state : STATE_TYPE;
    SIGNAL next_state : STATE_TYPE;

    -- Declare any pre-registered internal signals
    SIGNAL consigne_cld : std_ulogic_vector (dataBitNb-1 DOWNTO 0);
    SIGNAL endOfMsg_cld : std_ulogic ;
    SIGNAL newCharacter_cld : std_ulogic ;
    SIGNAL rxRd_cld : std_ulogic ;
    SIGNAL txData_cld : std_ulogic_vector (dataBitNb-1 DOWNTO 0);
    SIGNAL txWr_cld : std_ulogic ;

BEGIN

    -----------------------------------------------------------------
    clocked_proc : PROCESS ( 
        clock,
        reset
    )
    -----------------------------------------------------------------
    BEGIN
        IF (reset = '1') THEN
            current_state <= waitForCommand;
            -- Default Reset Values
            consigne_cld <= (others => '0');
            endOfMsg_cld <= '0';
            newCharacter_cld <= '0';
            rxRd_cld <= '0';
            txData_cld <= (others => '0');
            txWr_cld <= '0';
        ELSIF (clock'EVENT AND clock = '1') THEN
            current_state <= next_state;

            -- Combined Actions
            CASE current_state IS
                WHEN waitForCommand => 
                    newCharacter_cld <= '0';
                    rxRd_cld <= '0';
                    consigne_cld <= (others => '0');
                    endOfMsg_cld <= '0';
                    txData_cld <= (others => '0');
                    txWr_cld <= '0';
                WHEN dispatcher => 
                    IF (rxData = X"53") THEN 
                        rxRd_cld <= '1';
                    ELSE
                        rxRd_cld <= '1';
                    END IF;
                WHEN S_select => 
                    rxRd_cld <= '0';
                    newCharacter_cld <= '0';
                    IF (rxEmpty = '0' AND rxData/=X"53") THEN 
                        rxRd_cld <= '1';
                    END IF;
                WHEN S_receive => 
                    consigne_cld <= rxData;
                    if rxData /= X"65" then
                      newCharacter_cld <= '1';
                    end if;
                    IF (rxData /= X"65") THEN 
                    ELSIF (rxData = X"65") THEN 
                        endOfMsg_cld <= '1';
                    END IF;
                WHEN S_waitForOtherCharacter => 
                    rxRd_cld <= '0';
                    newCharacter_cld <= '0';
                    IF (rxEmpty = '0') THEN 
                        rxRd_cld <= '1';
                    END IF;
                WHEN OTHERS =>
                    NULL;
            END CASE;
        END IF;
    END PROCESS clocked_proc;
 
    -----------------------------------------------------------------
    nextstate_proc : PROCESS ( 
        current_state,
        rxData,
        rxEmpty
    )
    -----------------------------------------------------------------
    BEGIN
        CASE current_state IS
            WHEN waitForCommand => 
                IF (rxEmpty = '0') THEN 
                    next_state <= dispatcher;
                ELSE
                    next_state <= waitForCommand;
                END IF;
            WHEN dispatcher => 
                IF (rxData = X"53") THEN 
                    next_state <= S_select;
                ELSE
                    next_state <= waitForCommand;
                END IF;
            WHEN S_select => 
                IF (rxEmpty = '0' AND rxData/=X"53") THEN 
                    next_state <= S_receive;
                ELSE
                    next_state <= S_select;
                END IF;
            WHEN S_receive => 
                IF (rxData /= X"65") THEN 
                    next_state <= S_waitForOtherCharacter;
                ELSIF (rxData = X"65") THEN 
                    next_state <= waitForCommand;
                ELSE
                    next_state <= S_receive;
                END IF;
            WHEN S_waitForOtherCharacter => 
                IF (rxEmpty = '0') THEN 
                    next_state <= S_receive;
                ELSE
                    next_state <= S_waitForOtherCharacter;
                END IF;
            WHEN OTHERS =>
                next_state <= waitForCommand;
        END CASE;
    END PROCESS nextstate_proc;
 
    -- Concurrent Statements
    -- Clocked output assignments
    consigne <= consigne_cld;
    endOfMsg <= endOfMsg_cld;
    newCharacter <= newCharacter_cld;
    rxRd <= rxRd_cld;
    txData <= txData_cld;
    txWr <= txWr_cld;
END fsm;
